In Section~\ref{section:definitions} and Section~\ref{section:primitives} we have laid the necessary groundwork for our discussion of security. Building on this, in Section~\ref{section:theorems} we could present rigorous theorems about security. Before we get to proving some of these theorems in Section \ref{section:proofs}, we discuss some issues related to proofs in cryptography.

In this section, we explain three different techniques we use in proofs. First, \emph{reductions}, which are the basic concept that proofs of security rely on. Second, \emph{packages} and \emph{inlining} (and its opposite, \emph{outlining}), which are methods to modularize pseudocode, and thirdly, \emph{code equivalence proofs}, which
 prove that two systems described in pseudocode behave in the same way, i.e., have the same input-output behaviour (distribution). Jumping ahead, we will often split a `big game' into a `small game' together with a piece of code (\emph{package}) we put in front of the `small game' and call a \emph{reduction}. We then need to show that the 'small game' with the reduction behaves in the same way as the `big game', and we do so by \emph{inlining} the code of the small game into the reduction and showing that the result is the same as the `big game' by a \emph{code-equivalence} proof.


The necessity of reading this section depends on your background. Code equivalence might be familiar to you if you have worked in theoretical computer science, as might reduction proofs. However, we recommend you read the section on reductions even if you have used reductions before:
reductions in cryptography have much more flexibility than the reductions you might have encountered in a complexity theory course. In addition,
the way reductions are used in cryptography requires some thought, and we here introduce a framework which provides us with a consistent method  of writing reduction proofs (there are many ways of writing reductions, you do not need to use the framework we use in this book.).

\emph{Teaching note:} When teaching cryptography to students with no or little experience in proofs, giving them a framework for writing proofs is useful. It gives them additional structure and allows to build confidence with the method in a context where it is very clear which steps are right/allowed and which steps are wrong. In particular, we can then easily settle disagreements, since we can pinpoint exactly where a gap/mistake in an argument is (which is harder when using the prevalent method of `inlining in your head'.).